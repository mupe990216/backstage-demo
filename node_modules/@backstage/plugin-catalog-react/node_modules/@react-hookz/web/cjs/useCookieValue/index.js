"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useCookieValue = void 0;
/* eslint-disable @typescript-eslint/no-use-before-define,no-use-before-define */
const js_cookie_1 = __importDefault(require("js-cookie"));
const react_1 = require("react");
const useFirstMountState_1 = require("../useFirstMountState");
const useMountEffect_1 = require("../useMountEffect");
const useSyncedRef_1 = require("../useSyncedRef");
const const_1 = require("../util/const");
const cookiesSetters = new Map();
const registerSetter = (key, setter) => {
    let setters = cookiesSetters.get(key);
    if (!setters) {
        setters = new Set();
        cookiesSetters.set(key, setters);
    }
    setters.add(setter);
};
const unregisterSetter = (key, setter) => {
    const setters = cookiesSetters.get(key);
    // almost impossible to test in normal situation
    /* istanbul ignore next */
    if (!setters)
        return;
    setters.delete(setter);
    if (!setters.size) {
        cookiesSetters.delete(key);
    }
};
const invokeRegisteredSetters = (key, value, skipSetter) => {
    const setters = cookiesSetters.get(key);
    // almost impossible to test in normal situation
    /* istanbul ignore next */
    if (!setters)
        return;
    setters.forEach((s) => {
        if (s !== skipSetter)
            s(value);
    });
};
/**
 * Manages a single cookie.
 *
 * @param key Name of the cookie to manage.
 * @param options Cookie options that will be used during setting and deleting the cookie.
 */
function useCookieValue(key, options = {}) {
    // no need to test it, dev-only notification about 3rd party library requirement
    /* istanbul ignore next */
    if (process.env.NODE_ENV === 'development' && js_cookie_1.default === undefined) {
        throw new ReferenceError('Dependency `js-cookies` is not installed, it is required for `useCookieValue` work.');
    }
    // eslint-disable-next-line prefer-const
    let { initializeWithValue = true, ...cookiesOptions } = options;
    if (!const_1.isBrowser) {
        initializeWithValue = false;
    }
    const methods = (0, useSyncedRef_1.useSyncedRef)({
        set: (value) => {
            setState(value);
            js_cookie_1.default.set(key, value, cookiesOptions);
            // update all other hooks with the same key
            invokeRegisteredSetters(key, value, setState);
        },
        remove: () => {
            setState(null);
            js_cookie_1.default.remove(key, cookiesOptions);
            invokeRegisteredSetters(key, null, setState);
        },
        fetchVal: () => js_cookie_1.default.get(key) ?? null,
        fetch: () => {
            const val = methods.current.fetchVal();
            setState(val);
            invokeRegisteredSetters(key, val, setState);
        },
    });
    const isFirstMount = (0, useFirstMountState_1.useFirstMountState)();
    const [state, setState] = (0, react_1.useState)(isFirstMount && initializeWithValue ? methods.current.fetchVal() : undefined);
    (0, useMountEffect_1.useMountEffect)(() => {
        if (!initializeWithValue) {
            methods.current.fetch();
        }
    });
    (0, react_1.useEffect)(() => {
        registerSetter(key, setState);
        return () => {
            unregisterSetter(key, setState);
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [key]);
    return [
        state,
        // eslint-disable-next-line react-hooks/exhaustive-deps
        (0, react_1.useCallback)((value) => methods.current.set(value), []),
        // eslint-disable-next-line react-hooks/exhaustive-deps
        (0, react_1.useCallback)(() => methods.current.remove(), []),
        // eslint-disable-next-line react-hooks/exhaustive-deps
        (0, react_1.useCallback)(() => methods.current.fetch(), []),
    ];
}
exports.useCookieValue = useCookieValue;
